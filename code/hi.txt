rule 1: <program> ->  <moduleDeclarations> --> <otherModules> --> <driverModule> --> <otherModules> -->
rule 2: <moduleDeclarations> ->  <moduleDeclaration> --> <moduleDeclarations> -->
rule 3: <moduleDeclarations> ->  e -->
rule 4: <moduleDeclaration> ->  DECLARE --> MODULE --> ID --> SEMICOL -->
rule 5: <otherModules> ->  <module> --> <otherModules> -->
rule 6: <otherModules> ->  e -->
rule 7: <driverModule> ->  DRIVERDEF --> DRIVER --> PROGRAM --> DRIVERENDDEF --> <moduleDef> -->
rule 8: <module> ->  DEF --> MODULE --> ID --> ENDDEF --> TAKES --> INPUT --> SQBO --> <input_plist> --> SQBC --> SEMICOL --> <ret> --> <moduleDef> -->
rule 9: <ret> ->  RETURNS --> SQBO --> <output_plist> --> SQBC --> SEMICOL -->
rule 10: <ret> ->  e -->
rule 11: <input_plist> ->  ID --> COLON --> <dataType> --> <input_plist_ex> -->
rule 12: <input_plist_ex> ->  COMMA --> ID --> COLON --> <dataType> --> <input_plist_ex> -->
rule 13: <input_plist_ex> ->  e -->
rule 14: <output_plist> ->  ID --> COLON --> <type> --> <output_plist_ex> -->
rule 15: <output_plist_ex> ->  COMMA --> ID --> COLON --> <type> --> <output_plist_ex> -->
rule 16: <output_plist_ex> ->  e -->
rule 17: <dataType> ->  INTEGER -->
rule 18: <dataType> ->  REAL -->
rule 19: <dataType> ->  BOOLEAN -->
rule 20: <dataType> ->  ARRAY --> SQBO --> <range> --> SQBC --> OF --> <type> -->
rule 21: <type> ->  INTEGER -->
rule 22: <type> ->  REAL -->
rule 23: <type> ->  BOOLEAN -->
rule 24: <moduleDef> ->  START --> <statements> --> END -->
rule 25: <statements> ->  <statement> --> <statements> -->
rule 26: <statements> ->  e -->
rule 27: <statement> ->  <ioStmt> -->
rule 28: <statement> ->  <simpleStmt> -->
rule 29: <statement> ->  <declareStmt> -->
rule 30: <statement> ->  <condionalStmt> -->
rule 31: <statement> ->  <iterativeStmt> -->
rule 32: <ioStmt> ->  GET_VALUE --> BO --> ID --> BC --> SEMICOL -->
rule 33: <ioStmt> ->  PRINT --> BO --> <var> --> BC --> SEMICOL -->
rule 34: <var> ->  ID --> <whichId> -->
rule 35: <var> ->  NUM -->
rule 36: <var> ->  RNUM -->
rule 37: <var> ->  TRUE -->
rule 38: <var> ->  FALSE -->
rule 39: <whichId> ->  SQBO --> ID --> SQBC -->
rule 40: <whichId> ->  e -->
rule 41: <simpleStmt> ->  <assignmentStmt> -->
rule 42: <simpleStmt> ->  <moduleReuseStmt> -->
rule 43: <assignmentStmt> ->  ID --> <whichStmt> -->
rule 44: <whichStmt> ->  <lvalueIDStmt> -->
rule 45: <whichStmt> ->  <lvalueARRStmt> -->
rule 46: <lvalueIDStmt> ->  ASSIGNOP --> <expression> --> SEMICOL -->
rule 47: <lvalueARRStmt> ->  SQBO --> <index> --> SQBC --> ASSIGNOP --> <expression> --> SEMICOL -->
rule 48: <index> ->  NUM -->
rule 49: <index> ->  ID -->
rule 50: <moduleReuseStmt> ->  <optional> --> USE --> MODULE --> ID --> WITH --> PARAMETERS --> <idList> --> SEMICOL -->
rule 51: <optional> ->  SQBO --> <idList> --> SQBC --> ASSIGNOP -->
rule 52: <optional> ->  e -->
rule 53: <idList> ->  ID --> <idList_ex> -->
rule 54: <idList_ex> ->  COMMA --> ID --> <idList_ex> -->
rule 55: <idList_ex> ->  e -->
rule 56: <expression> ->  <AOBE> -->
rule 57: <expression> ->  MINUS --> <BorNBAE> -->
rule 58: <negOrPosAE> ->  MINUS --> <BorNBAE> -->
rule 59: <negOrPosAE> ->  <BorNBAE> -->
rule 60: <BorNBAE> ->  BO --> <arithmeticExpr> --> BC -->
rule 61: <BorNBAE> ->  <arithmeticExpr> -->
rule 62: <AOBE> ->  <AnyTerm> --> <WithLogOp> -->
rule 63: <WithLogOp> ->  <logicalOp> --> <AnyTerm2> --> <WithLogOp> -->
rule 64: <WithLogOp> ->  e -->
rule 65: <AnyTerm> ->  <arithmeticExpr> --> <WithRelOp> -->
rule 66: <AnyTerm2> ->  BO --> <AOBE> --> BC -->
rule 67: <AnyTerm2> ->  <AnyTerm> -->
rule 68: <WithRelOp> ->  <relationalOp> --> <negOrPosAE> --> <WithRelOp> -->
rule 69: <WithRelOp> ->  e -->
rule 70: <AOBE> ->  BO --> <AOBE> --> BC --> <alpha> -->
rule 71: <alpha> ->  <all_ops> --> <AOBE> -->
rule 72: <alpha> ->  e -->
rule 73: <all_ops> ->  <logicalOp> -->
rule 74: <all_ops> ->  <relationalOp> -->
rule 75: <all_ops> ->  <op1> -->
rule 76: <all_ops> ->  <op2> -->
rule 77: <arithmeticExpr> ->  <term> --> <N4> -->
rule 78: <N4> ->  <op1> --> <term> --> <N4> -->
rule 79: <N4> ->  e -->
rule 80: <term> ->  <factor> --> <N5> -->
rule 81: <N5> ->  <op2> --> <factor> --> <N5> -->
rule 82: <N5> ->  e -->
rule 83: <factor> ->  <var> -->
rule 84: <op1> ->  PLUS -->
rule 85: <op1> ->  MINUS -->
rule 86: <op2> ->  MUL -->
rule 87: <op2> ->  DIV -->
rule 88: <logicalOp> ->  AND -->
rule 89: <logicalOp> ->  OR -->
rule 90: <relationalOp> ->  LT -->
rule 91: <relationalOp> ->  LE -->
rule 92: <relationalOp> ->  GT -->
rule 93: <relationalOp> ->  GE -->
rule 94: <relationalOp> ->  EQ -->
rule 95: <relationalOp> ->  NE -->
rule 96: <declareStmt> ->  DECLARE --> <idList> --> COLON --> <dataType> --> SEMICOL -->
rule 97: <condionalStmt> ->  SWITCH --> BO --> ID --> BC --> START --> <caseStmts> --> <default> --> END -->
rule 98: <caseStmts> ->  CASE --> <value> --> COLON --> <statements> --> BREAK --> SEMICOL --> <MultiCase> -->
rule 99: <MultiCase> ->  CASE --> <value> --> COLON --> <statements> --> BREAK --> SEMICOL --> <MultiCase> -->
rule 100: <MultiCase> ->  e -->
rule 101: <value> ->  NUM -->
rule 102: <value> ->  TRUE -->
rule 103: <value> ->  FALSE -->
rule 104: <default> ->  DEFAULT --> COLON --> <statements> --> BREAK --> SEMICOL -->
rule 105: <default> ->  e -->
rule 106: <iterativeStmt> ->  FOR --> BO --> ID --> IN --> <range> --> BC --> START --> <statements> --> END -->
rule 107: <iterativeStmt> ->  WHILE --> BO --> <AOBE> --> BC --> START --> <statements> --> END -->
rule 108: <range> ->  NUM --> RANGEOP --> NUM -->
FIRSTS



<AOBE>
 ID --> NUM --> RNUM --> TRUE --> FALSE --> BO -->
<output_plist>
 ID -->
<idList>
 ID -->
<statement>
 USE --> SQBO --> ID --> FOR --> WHILE --> SWITCH --> DECLARE --> GET_VALUE --> PRINT -->
<whichStmt>
 SQBO --> ASSIGNOP -->
<WithLogOp>
 AND --> OR --> e -->
<moduleReuseStmt>
 USE --> SQBO -->
<idList_ex>
 e --> COMMA -->
<declareStmt>
 DECLARE -->
<MultiCase>
 e --> CASE -->
<simpleStmt>
 SQBO --> USE --> ID -->
<expression>
 FALSE --> TRUE --> RNUM --> NUM --> ID --> BO --> MINUS -->
<term>
 FALSE --> TRUE --> RNUM --> NUM --> ID -->
<index>
 ID --> NUM -->
<module>
 DEF -->
<lvalueARRStmt>
 SQBO -->
<negOrPosAE>
 ID --> NUM --> RNUM --> TRUE --> FALSE --> BO --> MINUS -->
<dataType>
 ARRAY --> BOOLEAN --> REAL --> INTEGER -->
<input_plist>
 ID -->
<var>
 FALSE --> TRUE --> RNUM --> NUM --> ID -->
<op2>
 DIV --> MUL -->
<N4>
 PLUS --> MINUS --> e -->
<output_plist_ex>
 e --> COMMA -->
<driverModule>
 DRIVERDEF -->
<program>
 DEF --> DECLARE --> DRIVERDEF -->
<iterativeStmt>
 WHILE --> FOR -->
<caseStmts>
 CASE -->
<logicalOp>
 OR --> AND -->
<whichId>
 e --> SQBO -->
<ioStmt>
 PRINT --> GET_VALUE -->
<input_plist_ex>
 e --> COMMA -->
<ret>
 e --> RETURNS -->
<WithRelOp>
 LT --> LE --> GT --> GE --> EQ --> NE --> e -->
<condionalStmt>
 SWITCH -->
<optional>
 e --> SQBO -->
<op1>
 MINUS --> PLUS -->
<range>
 NUM -->
<relationalOp>
 NE --> EQ --> GE --> GT --> LE --> LT -->
<BorNBAE>
 FALSE --> TRUE --> RNUM --> NUM --> ID --> BO -->
<factor>
 ID --> NUM --> RNUM --> TRUE --> FALSE -->
<value>
 FALSE --> TRUE --> NUM -->
<moduleDeclarations>
 DECLARE --> e -->
<otherModules>
 DEF --> e -->
<type>
 BOOLEAN --> REAL --> INTEGER -->
<moduleDeclaration>
 DECLARE -->
<moduleDef>
 START -->
<default>
 e --> DEFAULT -->
<N5>
 MUL --> DIV --> e -->
<assignmentStmt>
 ID -->
<lvalueIDStmt>
 ASSIGNOP -->
<statements>
 SQBO --> USE --> ID --> PRINT --> GET_VALUE --> DECLARE --> SWITCH --> WHILE --> FOR --> e -->
<arithmeticExpr>
 ID --> NUM --> RNUM --> TRUE --> FALSE -->
<AnyTerm>
 FALSE --> TRUE --> RNUM --> NUM --> ID -->
<all_ops>
 MUL --> DIV --> PLUS --> MINUS --> LT --> LE --> GT --> GE --> EQ --> NE --> AND --> OR -->
<alpha>
 OR --> AND --> NE --> EQ --> GE --> GT --> LE --> LT --> MINUS --> PLUS --> DIV --> MUL --> e -->
<AnyTerm2>
 ID --> NUM --> RNUM --> TRUE --> FALSE --> BO -->


FOLLOWS



<AOBE>
 BC --> SEMICOL -->
<output_plist>
 SQBC -->
<idList>
 COLON --> SQBC --> SEMICOL -->
<statement>
 FOR --> WHILE --> SWITCH --> DECLARE --> GET_VALUE --> PRINT --> ID --> USE --> SQBO --> BREAK --> END -->
<whichStmt>
 FOR --> WHILE --> SWITCH --> DECLARE --> GET_VALUE --> PRINT --> ID --> USE --> SQBO --> BREAK --> END -->
<WithLogOp>
 BC --> SEMICOL -->
<moduleReuseStmt>
 FOR --> WHILE --> SWITCH --> DECLARE --> GET_VALUE --> PRINT --> ID --> USE --> SQBO --> BREAK --> END -->
<idList_ex>
 COLON --> SQBC --> SEMICOL -->
<declareStmt>
 FOR --> WHILE --> SWITCH --> DECLARE --> GET_VALUE --> PRINT --> ID --> USE --> SQBO --> BREAK --> END -->
<MultiCase>
 END --> DEFAULT -->
<simpleStmt>
 FOR --> WHILE --> SWITCH --> DECLARE --> GET_VALUE --> PRINT --> ID --> USE --> SQBO --> BREAK --> END -->
<expression>
 SEMICOL -->
<term>
 MINUS --> PLUS --> NE --> EQ --> GE --> GT --> LE --> LT --> OR --> AND --> BC --> SEMICOL -->
<index>
 SQBC -->
<module>
 DEF --> DRIVERDEF --> $ -->
<lvalueARRStmt>
 FOR --> WHILE --> SWITCH --> DECLARE --> GET_VALUE --> PRINT --> ID --> USE --> SQBO --> BREAK --> END -->
<negOrPosAE>
 NE --> EQ --> GE --> GT --> LE --> LT --> OR --> AND --> BC --> SEMICOL -->
<dataType>
 SEMICOL --> COMMA --> SQBC -->
<input_plist>
 SQBC -->
<var>
 DIV --> MUL --> MINUS --> PLUS --> NE --> EQ --> GE --> GT --> LE --> LT --> OR --> AND --> BC --> SEMICOL -->
<op2>
 BO --> ID --> NUM --> RNUM --> TRUE --> FALSE -->
<N4>
 NE --> EQ --> GE --> GT --> LE --> LT --> OR --> AND --> BC --> SEMICOL -->
<output_plist_ex>
 SQBC -->
<driverModule>
 DEF --> $ -->
<program>
 $ -->
<iterativeStmt>
 FOR --> WHILE --> SWITCH --> DECLARE --> GET_VALUE --> PRINT --> ID --> USE --> SQBO --> BREAK --> END -->
<caseStmts>
 END --> DEFAULT -->
<logicalOp>
 ID --> NUM --> RNUM --> TRUE --> FALSE --> BO -->
<whichId>
 DIV --> MUL --> MINUS --> PLUS --> LT --> LE --> GT --> GE --> EQ --> NE --> AND --> OR --> BC --> SEMICOL -->
<ioStmt>
 FOR --> WHILE --> SWITCH --> DECLARE --> GET_VALUE --> PRINT --> ID --> USE --> SQBO --> BREAK --> END -->
<input_plist_ex>
 SQBC -->
<ret>
 START -->
<WithRelOp>
 OR --> AND --> BC --> SEMICOL -->
<condionalStmt>
 FOR --> WHILE --> SWITCH --> DECLARE --> GET_VALUE --> PRINT --> ID --> USE --> SQBO --> BREAK --> END -->
<optional>
 USE -->
<op1>
 BO --> FALSE --> TRUE --> RNUM --> NUM --> ID -->
<range>
 BC --> SQBC -->
<relationalOp>
 MINUS --> ID --> NUM --> RNUM --> TRUE --> FALSE --> BO -->
<BorNBAE>
 LT --> LE --> GT --> GE --> EQ --> NE --> AND --> OR --> BC --> SEMICOL -->
<factor>
 DIV --> MUL --> MINUS --> PLUS --> NE --> EQ --> GE --> GT --> LE --> LT --> OR --> AND --> BC --> SEMICOL -->
<value>
 COLON -->
<moduleDeclarations>
 DEF --> DRIVERDEF -->
<otherModules>
 DRIVERDEF --> $ -->
<type>
 SEMICOL --> COMMA --> SQBC -->
<moduleDeclaration>
 DECLARE --> DEF --> DRIVERDEF -->
<moduleDef>
 DEF --> DRIVERDEF --> $ -->
<default>
 END -->
<N5>
 MINUS --> PLUS --> NE --> EQ --> GE --> GT --> LE --> LT --> OR --> AND --> BC --> SEMICOL -->
<assignmentStmt>
 FOR --> WHILE --> SWITCH --> DECLARE --> GET_VALUE --> PRINT --> ID --> USE --> SQBO --> BREAK --> END -->
<lvalueIDStmt>
 FOR --> WHILE --> SWITCH --> DECLARE --> GET_VALUE --> PRINT --> ID --> USE --> SQBO --> BREAK --> END -->
<statements>
 BREAK --> END -->
<arithmeticExpr>
 NE --> EQ --> GE --> GT --> LE --> LT --> OR --> AND --> BC --> SEMICOL -->
<AnyTerm>
 OR --> AND --> BC --> SEMICOL -->
<all_ops>
 ID --> NUM --> RNUM --> TRUE --> FALSE --> BO -->
<alpha>
 BC --> SEMICOL -->
<AnyTerm2>
 OR --> AND --> BC --> SEMICOL -->


-----FIRST AND FOLLOW AUTOMATED-----

Press:
1=> For the clean code
2=> For printing token generated by lexer
3=> For verifying the syntactic correctness
4=> For printing the parse tree
5=> For Exiting


Correct Syntax.


Line 4 ID encountered->readArr 1 Module Declared.DeclaringreadArr
Line 5 ID encountered->arraySum 2 ModuleDefinition.
Line 6 ID encountered->list 6 Declared of type ARRAY. 
REAL.
Line 6 ID encountered->n 6 Declared of type INTEGER. 
error free
Line 7 ID encountered->sum 7 35 0 0
Declared of type REAL.
Line 8 parent offset 0
Line 9 ID encountered->index 4 Nesting:1 Offset:0
index Declared of typeINTEGER in nesting 1 and offset 0.
Yeahhhhh index
Line 10 ID encountered->t 4 Nesting:1 Offset:0
t Declared of typeBOOLEAN in nesting 1 and offset 0.
Yeahhhhh t
Line 10 ID encountered->a Nesting:1 Offset:0
Declared of typeBOOLEAN in nesting 1 and offset 0.
declared and found a
Line 11 ID encountered->sum 3 Nesting:1 Offset:0
Declared.
Line 12 ID encountered->t 3 Nesting:1 Offset:0
Declared.
Line 12 ID encountered->sum 3 Nesting:1 Offset:0
Declared.
Line 13 ID encountered->sum 3 Nesting:1 Offset:0
Declared.
Line 13 ID encountered->t 3 Nesting:1 Offset:0
Declared.
Line 14 parent offset 0
Line 15 ID encountered->p 4 type of array BOOLEAN
Nesting:2 Offset:0
Nesting:1 Offset:0
p Declared of typeBOOLEAN in nesting 2 and offset 0.
Yeahhhhh p
Line 15 ID encountered->q Nesting:2 Offset:0
Nesting:1 Offset:0
Declared of typeBOOLEAN in nesting 2 and offset 0.
declared and found q
Line 15 ID encountered->r Nesting:2 Offset:0
Nesting:1 Offset:0
Declared of typeBOOLEAN in nesting 2 and offset 0.
declared and found r
Line 16 ID encountered->newarr 4 type of array REAL
Nesting:2 Offset:0
Nesting:1 Offset:0
newarr Declared of typeREAL in nesting 2 and offset 0.
Yeahhhhh newarr
Line 17 ID encountered->u 4 Nesting:2 Offset:0
Nesting:1 Offset:0
u Declared of typeBOOLEAN in nesting 2 and offset 0.
Yeahhhhh u
Line 17 ID encountered->v Nesting:2 Offset:0
Nesting:1 Offset:0
Declared of typeBOOLEAN in nesting 2 and offset 0.
declared and found v
Line 18 ID encountered->sum 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 18 ID encountered->sum 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 19 parent offset 0
Line 20 ID encountered->x 4 Nesting:3 Offset:0
Nesting:2 Offset:0
Nesting:1 Offset:0
x Declared of typeINTEGER in nesting 3 and offset 0.
Yeahhhhh x
Line 20 ID encountered->y Nesting:3 Offset:0
Nesting:2 Offset:0
Nesting:1 Offset:0
Declared of typeINTEGER in nesting 3 and offset 0.
declared and found y
Line 21 ID encountered->x 3 Nesting:3 Offset:0
Declared.
Line 21 ID encountered->y 3 Nesting:3 Offset:0
Declared.
Line 21 ID encountered->index 3 Nesting:3 Offset:0
Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 22 ID encountered->sum 3 Nesting:3 Offset:0
Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 22 ID encountered->p 3 Nesting:3 Offset:0
Nesting:2 Offset:0
Declared.
Line 23 ID encountered->t 3 Nesting:3 Offset:0
Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 23 ID encountered->y 3 Nesting:3 Offset:0
Declared.
Line 23 ID encountered->x 3 Nesting:3 Offset:0
Declared.
Line 23 ID encountered->newarr 3 Nesting:3 Offset:0
Nesting:2 Offset:0
Declared.
Line 23 ID encountered->v 3 Nesting:3 Offset:0
Nesting:2 Offset:0
Declared.
Line 25 ID encountered->index 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 25 ID encountered->index 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 25 ID encountered->x 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Not declared.
Line 26 ID encountered->r 3 Nesting:2 Offset:0
Declared.
Line 26 ID encountered->v 3 Nesting:2 Offset:0
Declared.
Line 26 ID encountered->p 3 Nesting:2 Offset:0
Declared.
Line 26 ID encountered->v 3 Nesting:2 Offset:0
Declared.
Line 26 ID encountered->q 3 Nesting:2 Offset:0
Declared.
Line 26 ID encountered->v 3 Nesting:2 Offset:0
Declared.
Line 27 ID encountered->r 3 Nesting:2 Offset:0
Declared.
Line 27 ID encountered->v 3 Nesting:2 Offset:0
Declared.
Line 27 ID encountered->p 3 Nesting:2 Offset:0
Declared.
Line 27 ID encountered->v 3 Nesting:2 Offset:0
Declared.
Line 27 ID encountered->list 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 27 ID encountered->v 3 Nesting:2 Offset:0
Declared.
Line 28 ID encountered->newarr 3 Nesting:2 Offset:0
Declared.
Line 28 ID encountered->v 3 Nesting:2 Offset:0
Declared.
Line 28 ID encountered->list 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 28 ID encountered->v 3 Nesting:2 Offset:0
Declared.
Line 28 ID encountered->list 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 28 ID encountered->v 3 Nesting:2 Offset:0
Declared.
Line 29 ID encountered->t 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 29 ID encountered->list 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 29 ID encountered->v 3 Nesting:2 Offset:0
Declared.
Line 29 ID encountered->newarr 3 Nesting:2 Offset:0
Declared.
Line 29 ID encountered->v 3 Nesting:2 Offset:0
Declared.
Line 30 ID encountered->a 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 30 ID encountered->t 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 30 ID encountered->list 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 30 ID encountered->v 3 Nesting:2 Offset:0
Declared.
Line 32 ID encountered->index 3 Nesting:1 Offset:0
Declared.
Line 33 parent offset 0
Line 34 ID encountered->y_1 4 Nesting:2 Offset:1
Nesting:1 Offset:0
y_1 Declared of typeREAL in nesting 2 and offset 1.
Yeahhhhh y_1
Line 34 ID encountered->y_2 Nesting:2 Offset:1
Nesting:1 Offset:0
Declared of typeREAL in nesting 2 and offset 1.
declared and found y_2
Line 35 ID encountered->k 4 type of array REAL
Nesting:2 Offset:1
Nesting:1 Offset:0
k Declared of typeREAL in nesting 2 and offset 1.
Yeahhhhh k
Line 35 ID encountered->l Nesting:2 Offset:1
Nesting:1 Offset:0
Declared of typeREAL in nesting 2 and offset 1.
declared and found l
Line 35 ID encountered->m Nesting:2 Offset:1
Nesting:1 Offset:0
Declared of typeREAL in nesting 2 and offset 1.
declared and found m
Line 36 ID encountered->x 4 Nesting:2 Offset:1
Nesting:1 Offset:0
x Declared of typeREAL in nesting 2 and offset 1.
Yeahhhhh x
Line 37 ID encountered->t 3 Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 37 ID encountered->index 3 Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 37 ID encountered->n 3 Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 38 ID encountered->t 3 Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 39 parent offset 1
Line 40 ID encountered->list 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 40 ID encountered->index 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 41 ID encountered->m 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Declared.
Line 41 ID encountered->j 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Not declared.
Line 41 ID encountered->k 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Declared.
Line 41 ID encountered->j 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Not declared.
Line 42 ID encountered->sum 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 42 ID encountered->sum 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 42 ID encountered->list 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 42 ID encountered->index 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 42 ID encountered->k 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Declared.
Line 42 ID encountered->index 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 43 ID encountered->value 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Not declared.
Line 43 ID encountered->sum 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 44 ID encountered->x_1 4 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
x_1 Declared of typeINTEGER in nesting 3 and offset 1.
Yeahhhhh x_1
Line 44 ID encountered->x_2 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Declared of typeINTEGER in nesting 3 and offset 1.
declared and found x_2
Line 45 ID encountered->x_1 3 Nesting:3 Offset:1
Declared.
Line 45 ID encountered->index 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 46 ID encountered->x_2 3 Nesting:3 Offset:1
Declared.
Line 46 ID encountered->x_1 3 Nesting:3 Offset:1
Declared.
Line 46 ID encountered->x_2 3 Nesting:3 Offset:1
Declared.
Line 48 ID encountered->u1 4 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
u1 Declared of typeREAL in nesting 3 and offset 1.
Yeahhhhh u1
Line 48 ID encountered->u2 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Declared of typeREAL in nesting 3 and offset 1.
declared and found u2
Line 49 ID encountered->u2 3 Nesting:3 Offset:1
Declared.
Line 49 ID encountered->n 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 49 ID encountered->u1 3 Nesting:3 Offset:1
Declared.
Line 51 ID encountered->sum 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Declared.
Line 52 ID encountered->x 4 Nesting:3 Offset:1
Nesting:2 Offset:1
Redeclaration.
Line 52 ID encountered->u1 Nesting:3 Offset:1
Redeclaration.
Line 52 ID encountered->x_5 Nesting:3 Offset:1
Nesting:2 Offset:1
Nesting:1 Offset:0
Declared of typeINTEGER in nesting 3 and offset 1.
declared and found x_5
Line 53 ID encountered->y_1 3 Nesting:3 Offset:1
Nesting:2 Offset:1
Declared.
Line 57 ID encountered->x_2 3 Nesting:1 Offset:0
Not declared.
Driver Function seen.
Line 60 parent offset 0
Line 61 ID encountered->A 4 type of array REAL
Nesting:1 Offset:0
A Declared of typeREAL in nesting 1 and offset 0.
Yeahhhhh A
Line 62 ID encountered->k 4 Nesting:1 Offset:0
k Declared of typeINTEGER in nesting 1 and offset 0.
Yeahhhhh k
Line 63 ID encountered->l 4 Nesting:1 Offset:0
l Declared of typeINTEGER in nesting 1 and offset 0.
Yeahhhhh l
Line 64 ID encountered->m 4 Nesting:1 Offset:0
m Declared of typeINTEGER in nesting 1 and offset 0.
Yeahhhhh m
Line 65 ID encountered->s 4 Nesting:1 Offset:0
s Declared of typeREAL in nesting 1 and offset 0.
Yeahhhhh s
Line 66 ID encountered->k 3 Nesting:1 Offset:0
Declared.
Line 68 ID encountered->s 5 Nesting:1 Offset:0
Declared.
Line 68 ID encountered->arraySum Line 68 ID encountered->A 5 Nesting:1 Offset:0
Declared.
ID->k Nesting:1 Offset:0
Declared.
Line 69 ID encountered->readArr Line 69 ID encountered->A 5 Nesting:1 Offset:0
Declared.
ID->k Nesting:1 Offset:0
Declared.
ID->l Nesting:1 Offset:0
Declared.
ID->m Nesting:1 Offset:0
Declared.
Line 70 ID encountered->s 5 Nesting:1 Offset:0
Declared.
Line 70 ID encountered->arraySum Line 70 ID encountered->A 5 Nesting:1 Offset:0
Declared.
ID->k Nesting:1 Offset:0
Declared.
ID->l Nesting:1 Offset:0
Declared.
ID->m Nesting:1 Offset:0
Declared.
Line 71 ID encountered->s 3 Nesting:1 Offset:0
Declared.
Line 74 ID encountered->readArr 2 ModuleDefinition.
Line 75 ID encountered->arr1 6 Declared of type ARRAY. 
BOOLEAN.
Line 75 ID encountered->k 6 Declared of type INTEGER. 
error free
Line 76 parent offset 0
Line 77 ID encountered->tempvar 4 Nesting:1 Offset:0
tempvar Declared of typeREAL in nesting 1 and offset 0.
Yeahhhhh tempvar
Line 78 ID encountered->i 4 Nesting:1 Offset:0
i Declared of typeINTEGER in nesting 1 and offset 0.
Yeahhhhh i
Line 79 ID encountered->i 3 Nesting:1 Offset:0
Declared.
Line 80 ID encountered->x_1 3 Nesting:1 Offset:0
Not declared.
Line 80 ID encountered->i 3 Nesting:1 Offset:0
Declared.
Line 80 ID encountered->u1 3 Nesting:1 Offset:0
Not declared.
Line 81 ID encountered->i 4 Nesting:1 Offset:0
Redeclaration.
Line 82 ID encountered->i 3 Nesting:1 Offset:0
Declared.
Line 82 ID encountered->k 3 Nesting:1 Offset:0
Declared.
Line 83 parent offset 0
Line 84 ID encountered->x_1 4 Nesting:2 Offset:0
Nesting:1 Offset:0
x_1 Declared of typeBOOLEAN in nesting 2 and offset 0.
Yeahhhhh x_1
Line 84 ID encountered->x_2 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared of typeBOOLEAN in nesting 2 and offset 0.
declared and found x_2
Line 85 ID encountered->x_1 3 Nesting:2 Offset:0
Declared.
Line 85 ID encountered->u2 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Not declared.
Line 86 ID encountered->tempvar 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 87 ID encountered->x_1 4 Nesting:2 Offset:0
Redeclaration.
Line 87 ID encountered->x_3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared of typeINTEGER in nesting 2 and offset 0.
declared and found x_3
Line 88 ID encountered->arr1 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 88 ID encountered->i 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 88 ID encountered->tempvar 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 89 ID encountered->i 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 89 ID encountered->i 3 Nesting:2 Offset:0
Nesting:1 Offset:0
Declared.
Line 91 ID encountered->x_2 4 Nesting:1 Offset:0
x_2 Declared of typeBOOLEAN in nesting 1 and offset 0.
Yeahhhhh x_2
Line 91 ID encountered->x_1 Nesting:1 Offset:0
Declared of typeBOOLEAN in nesting 1 and offset 0.
declared and found x_1
Line 91 ID encountered->x_3 Nesting:1 Offset:0
Declared of typeBOOLEAN in nesting 1 and offset 0.
declared and found x_3
Type Error in line 22: BOOLEAN type var invalid here
Type Error in line 22: Mismatch between REAL and BOOLEAN
Type Error in line 26: BOOLEAN type var invalid here
Type Error in line 26: BOOLEAN type var invalid here
Type Error in line 27: BOOLEAN type var invalid here
Type Error in line 30: Expecting BOOLEAN type expression here
Type Error in line 43: Mismatch between DUMMY and REAL
Type Error in line 49: Mismatch between REAL and INTEGER
Type Mismatch in line 69: Expected BOOLEAN but got REAL
Error in line 69: More parameters passed into the function
Error in line 70: More parameters passed into the function
Type Error in line 80: Mismatch between DUMMY and INTEGER
Type Error in line 88: Mismatch between BOOLEAN and REAL
SYMBOL TABLE



1	    list	array(15,REAL)	    8 to 58	      1	   60	0
2	       n	   INTEGER	         8 to 58	 1	    2	60
3	     sum	      REAL	         8 to 58	 1	    4	62
4	   index	   INTEGER	         8 to 58	 1	    2	66
5	       t	   BOOLEAN	         8 to 58	 1	    1	68
6	       a	   BOOLEAN	         8 to 58	 1	    1	69
7	       p	array(12,BOOLEAN)	   14 to 31	      2	   12	70
8	       q	array(12,BOOLEAN)	   14 to 31	      2	   12	82
9	       r	array(12,BOOLEAN)	   14 to 31	      2	   12	94
10	  newarr	array(15,REAL)	   14 to 31	      2	   60	106
11	       u	   BOOLEAN	        14 to 31	 2	    1	166
12	       v	   BOOLEAN	        14 to 31	 2	    1	167
13	       x	   INTEGER	        19 to 24	 3	    2	168
14	       y	   INTEGER	        19 to 24	 3	    2	170
15	     y_1	      REAL	        33 to 56	 2	    4	172
16	     y_2	      REAL	        33 to 56	 2	    4	176
17	       k	array(10,REAL)	   33 to 56	      2	   40	180
18	       l	array(10,REAL)	   33 to 56	      2	   40	220
19	       m	array(10,REAL)	   33 to 56	      2	   40	260
20	       x	      REAL	        33 to 56	 2	    4	300
21	     x_1	   INTEGER	        39 to 55	 3	    2	304
22	     x_2	   INTEGER	        39 to 55	 3	    2	306
23	      u1	      REAL	        39 to 55	 3	    4	308
24	      u2	      REAL	        39 to 55	 3	    4	312
25	     x_5	   INTEGER	        39 to 55	 3	    2	316
26	       A	array(15,REAL)	   60 to 72	      1	   60	0
27	       k	   INTEGER	        60 to 72	 1	    2	60
28	       l	   INTEGER	        60 to 72	 1	    2	62
29	       m	   INTEGER	        60 to 72	 1	    2	64
30	       s	      REAL	        60 to 72	 1	    4	66
31	    arr1	array(15,BOOLEAN)	   76 to 92	      1	   15	0
32	       k	   INTEGER	        76 to 92	 1	    2	15
33	 tempvar	      REAL	        76 to 92	 1	    4	17
34	       i	   INTEGER	        76 to 92	 1	    2	21
35	     x_1	   BOOLEAN	        83 to 90	 2	    1	23
36	     x_2	   BOOLEAN	        83 to 90	 2	    1	24
37	     x_3	   INTEGER	        83 to 90	 2	    2	25
38	     x_2	   BOOLEAN	        76 to 92	 1	    1	27
39	     x_1	   BOOLEAN	        76 to 92	 1	    1	28
40	     x_3	   BOOLEAN	        76 to 92	 1	    1	29

Press:
1=> For the clean code
2=> For printing token generated by lexer
3=> For verifying the syntactic correctness
4=> For printing the parse tree
5=> For Exiting
